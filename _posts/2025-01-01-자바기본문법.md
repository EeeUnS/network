---
layout: post
comments : true
title:  "[개체지향] 자바기본문법"
date:   2025-01-01 22:53:01 +0900
---

자바는 무조건 클래스가 필요하다
public은 무조건 한번만 쓸수있음

class안에 내포nested 클래스를 만들수 있음 클래스 안에는 public 여러개여도됨 

main함수는 무조건 이 모형
```
pulbic static void main(String[] args)
{

}
```
-----
System.out.println(~)
ln 은 라인
C#의 WriteLine과 유사
print() 함수도있음 C#의 Write()와 유사

out은 System 클래스의 정적 멤버 변수
out은 객체 자료형은 PrintStream(자바 표준 출력 스트림) 클래스

# System.out.printf(~)
C와 동일

# %s, System.lineSeparator() 은 os에 따른 개행문자를 내놓는다

# 가변인자
Object... args 
Object는 모든 자료형

---
# package <패키지 경로>
C#의 namespace와 비슷
종류
1. bulit-in 자바 기본 패키지 
java.~~

2. user-defined 패키지

장점 : 이름 충돌 문제 피함

패키지 이름의 중복을 최소화 해야함.
그래서 보통 회사의 도메인명을 패키지 이름에 사용.




# 폴더 구조 정리

```
프로젝트 최상위 폴더
|
src : 모든 java파일이 들어가는 폴더
|
academy : 최상위 패키지 폴더
|
pocu
{
    hellopocu.java : 메인함수가 있는 자바 파일
    ~~~ : 패키지 이름 / 하위패키지도 만들수있음
    |
    ~~.java
}
```

# 커맨드 라인에서 컴파일 하기
command
```
hellopocu> javac -d class\ src\academy\pocu\*.java
```
class
|
academy
|
pocu
|hellopocu.class //생성

javac 명렁어
```
javac -d <컴파일 결과물 저장경로> <java파일>
```
-d : class파일을 저장할 경로 .java 파일의 패키지 구조와 동일한 폴더가 생김.

command
```
java -classpath D:\hellopocu\class\ academy.pocu.hellopocu
java - class path  <class 파일 위치 > <클래스 이름>
```

자바는 실행파일이 나오지않음
대신 바이트 코드가(.class) 나옴

```
<클래스 이름>
 ```
반드시 main함수가 있어야함.

-classpath 
.class 파일의 위치를 알려주는 옵션
패키지를 포함하는 폴더의 경로를 적어야함.

클래스 이름앞에 반드시 패키지 이름을 붙여야함. 안붙이면 에러
```
java -classpath D:\hellopocu\class\ hellopocu X
```
# 배포법

C#
라이브러리 .dll
프로그램 .exe

java : .jar

# 새로운 폴더 추가
패키지에 lib폴더 추가

# jar 명령어


```
jar <option> <jar 파일 이름> <최상위 패키지 경로>

jar -cf ..\lib\hellopocu.jar academy
.jar 파일을 만드는 명령어
```

-cf 
c : create 
f : jar파일의 이름을 지정 f뒤에 파일명이 와야함


.jar는 사실 .zip파일

.jar내부에
META-INF\MANIFEST.MF라는 파일이 생성.


MANIFEST 파일

자바 애플리케이션의 정보를 담고있는 메타데이터 파일
.jar파일을 만들때 이 파일을 같이 넣어줄수있음
메인함수에 대한 정보를 넣어야함.

src
|
Manifest.txt
{
    Main-Class:academy.pocu.hellopocu
}


```
jar -cfm ..\lib\hellopocu.jar ..\src\Manifest.txt academy
```
-m manifest파일도 넣겠다는 의미

진짜 실행
```
java -jar lib\hellopocu.jar
```
------

# 외부 패키지 안에 들어있는 클래스 사용하기

import java.util.Random

```
import <패키지 이름>.<클래스 이름>;
import <패키지 이름>.*;
```
C# 의 using
C의 #include

java.lang

기본패키지
자동으로 import되는 패키지임
System은  java.lang안에 있는 클래스 중 하나

------

# 자바 실행 모델

## 전통적인 컴파일 방식 ex C
소스코드(.c . h) - 전처리기 - 확장된 소스 코드 - 컴파일러 - 어셈블리 코드 - 어셈블러 - 오브젝트 코드 - 링커 - 머신 코드 실행 파일 (.exe .out)


컴파일을 하면 실행 파일이 나옴
실행 파일은 기계어, 운영체제가 직접 실행하는 파일.
각 운영체제, 디바이스 마다 실행파일을 따로 만들어야 함.
컴파일러가 소스코드를 각 운영체제/디바이스에 맞는 기계어로 바꿔줌
소스코드 수정x
C는 이런고나점에서 크로스 플랫폼



## 자바의 컴파일 모델

컴파일 결과 : 바이트 코드

JVM이라는 특수한 프로그램이 이해하는 명령어
JVM이 실행중에 최종 플랫폼에 맞는 명령어로 바꿔서 실행해줌.
기계어보다 느림.

자바 가상 머신(JAVA VIRTUAL MACHINE)
각 운영체제 디바이스 마다 다른 버전 설치.-> 운영체제,디바이스 영향X
과거 인터프리터 방식으로 동작.
최근 JIT(just in time)컴파일을 추가
여러가지 방식이 공존.


# 자바가 인기 있었던 이유?

## 자바 애플릿

현재는 사망

앱 브라우저 안에서 실행가능한 작은 자바 프로그램

1. 프로그래머가 코드 패키지를 웹에 업로드
2. 사용자가 웹 브라우저에 페이지 방문
3. 웹 브라우저가 이 패키지를 다운로드 후 실행

웹안의jvm

장점 : 
당시 데스크탑수준의 기능을 웹에서 사용할수있는 유일한 플랫폼
미래에 새로운 플랫폼이 나와도 다시 컴파일 안해도됨

현재 최신 웹 브라우저들은 지원X
웹 표준만으로 기능 구현 가능
js 웹 어셈블리 등으로 대체
서블릿servlet 이라는 비슷한 개념의 프로그램이 아직 유효


------
# 정수형 자료형

| 이름      | 바이트기준 |
| ------- | ----- |
| byte    | 1     |
| short   | 2     |
| int     | 4     |
| long    | 8     |
| float   | 4     |
| double  | 8     |
| boolean | 1bit  |
| char    | 2     |


C# 자료형 크기가 고정
C와 달리 sizeof가 필요X
부호있는 자료형만 존재
예외 char 

## unsigned가 없어서 생기는 문제

1. 개념적으로 음수가 나올수없는 것들이 음수가 들어올 가능성을 열어줌으로서
컴파일타임에 잡아줄수있는것을 못잡게 됨.
따라서 의도하지않은 문제가 일어날 가능성이 높아짐.

2. 일반적으로 색상을 저장할때 8비트 사용 0~255 / 자바에서는 byte로 표현 불가능 따라서 short사용

대체제로서 Integer 클래스 존재.

## char
- java의 유일한 부호 없는 자료형
- 표준은 정수형
- 유니코드의 최댓값은 U+10FFFF
- char로 모든 유니코드 표현X
- 자바 탄생시 유니코드의 최댓값은 U+FFFF
- C# ,C로 마찬가지로 한계를 가지고있음.
- U+FFFF보다 큰 유니코드를 표현하려면 String을 사용해야 함.

# 기본 자료형은 모두 값형 임.

- 값형은 복사가능
- 참조형은 X

# String

- 연속된 문자를 표현하는 클래스형
- 클래스형은 참조형
- 연속된 문자를 저장하는 메모리
- 위 데이터를 처리할 수 있는 각종 메서드
- immutable
- 바꾸고 싶으면 새로운 문자열을 만들어야함.



# 리터럴

```
long num2 = 1234567890L;
long num2 = 1234567890l;
```

int 리터럴 : 없음
long : L or l
생략가능
int 범위보다 큰 수 일때 생략하면 컴파일 오류
- 16진수 :0x
- 2진수 0b
- 8진수 0

float : F f
double : D d // 생략o 잘안씀

문자 : 작은따옴표
문자열 : 큰 따옴표
유니코드표현 \unnnn
이스케이프 : \로 시작

```
\' \" \\ \r \n \f \t \b \ddd
```

null : 참조형에 사용 가능(C와 동일)

_

```
int num = 12_345_678;
```
큰 숫자의 가독성을 높이기 위해 사용(쉼표 찍듯이)


# final 
const
- 지역 변수
- 클래스 멤버 변수
- 메서드 매개변수
- 클래스와 메서드

C#에 const는 자동으로 static이 붙기에 static const는 컴파일에러
자바는 가능


final을 붙이면서 매개 변수 인자값 변경을 못하게 할수있다.
```
public int add(fianl float op1,...){
    op1+=1 // 컴파일 오류
}

```
C에서도 가능
C#에선 불가능

## final 변수 초기화

1. 선언과 동시에
2. 사용하기 전에만
- C와 C#의 const와는 다름.
- C#의 readonly키워드는 final처럼 선언 후에 초기화 가능
- 지역변수일경우 사용전에만 초기화하면됨.
- 멤버변수일 경우 생성자에서 초기화 가능,다른 메서드에선 불가능.


# 주석
```
//
/**/

//javadoc주석
/**
*/
```

javadoc
- 클래스,매서드, 멤버 변수, 인터페이스 위에 위치
- 이로부터 자동으로 java api문서를 생성
- C#도 /// 주석을 통해 비슷한 기능지원
- C,C++에서는 Doxygen을 사용
- @<태그> 
- @param  : 메서드의 매개변수
- @return : 반환값
- 나머지기능을 알아서 찾아볼것.


# 연산자

1. exp++ exp--
2. ++exp --exp +exp -exp ~ ! (casting)
3. * / %
4.  + - 
5.   << >>  >>>
6.    < >  <= >= instanceof
7.    == != 
8.    &
9.    ^
10.   |
11.   &&
12.   ||
13.   ? :
14.   -> 포인터연산아님
15.   = += -= *= /= %= &= ^= |= <<= >>= >>>=
 
# 산술연산자

- 숫자를 표현하는 자료형만 피연산자 사용가능
- 예외 문자열 더하기
- 불리언 사용불가
- 문자형도 정수로 생각


# 대입연산자
- 값형일 경우 값을 복사.
- 참조형일 경우 주소를 복사(얕은 복사)

# 자료형 변환
- 암시적캐스팅
- 묵시적캐스팅
- 클래스도 가능

# 논리 연산자

short circuit 평가를 한다.

or 연산자가 앞부분이 트루인경우 뒷계산을 하지않는다.


# 문자열 비교

문자열은 참조형
문자열 변수에 저장돼 있는건 메모리주소
==는 주소를 비교한다.
```JAVA
String name1 = "Nana" ;
String name2 = "Nana" ; //서로 주소가 같다
```
- String을 new로 생성하지 않은경우 같은 문자열을 상수열로 사용할때 같은 주소를 가르키도록 내부 최적화를 해놓음
- string constant pool, string pool

그래서 실제 문자열 자체는 *equals()* 메서드를 사용해야 한다.

```
boolean inSame1 = name1.equals(name2);
```
String에 다양한 멤버 함수가있으니 찾아볼것.
C#에서는 연산자 오버로딩으로 == 지원 자바에선 지원 X
메서드 오버로딩 지원
String용 +와 += 연산자 지원.
```java
String msg = "ID: ";
msg += 49503;  //ID: 49503
```
string + 는 성능저하를 일으킬수있기에 자주사용할때는 
printf 포맷사용 or string builder라는 좀더 좋은 클래스가있음.


# 비트 이동 연산자

- << n
- >> n &#62;	
-  몇칸 이동하는지는 오른쪽 피연산자로 지정
  
## >>>

- 부호없는 비트 이동 연산자
- 오른쪽으로 이동 후 남는 공간을 '0'으로 채움
- 부호없는 자료형이 없기에 이렇게 연산자를 따로 만듦

# if
내가 아는 그 if
# switch case
```java
switch (표현식)
{
    case  <상수라벨1>:
        ~
        break;
    default:
        ~
        break;
}
```
- 정수형,열거형, String사용가능(C와 다르고 C#과 같음)
- break 빼먹으면 fall-through(C#과 다르고 C와 같음)
- C#에서는 break빼먹으면 컴파일에러

# for, while ,do while, continue, break, goto

goto는 자바에는 없음.
다중 for문 탈출에 goto는 유용함

break

## break <라벨 이름>;
```
<라벨 이름>이 달린 코드 블록을 탈출함.
```

```java
outer:
for(~)
{
    if()
    {
        break outer;
    }
}
```
break를 감싸고 있는 라벨로만 점프가능
아닐시 컴파일 오류
goto의 장점만 뽑음
continue도 라벨사용가능

## foreach문
```java
for(int score : scores)
{}
```
cpp의 범위지정 for문과 동일

```C#
foreach (int score in scores)
{}
```


# 함수

method라고도 부름.


# 참조형 인자
참조형 인자는 C의 포인터 넘기는것과 같음.
따라서 원본이 바뀔수있음.
C에선 *, C#에선 ref

fianl붙여도 여전히 바뀜. 
주솟값은 바뀌지않음.
주소가 가르키는 값은 바뀜


#  1차원 배열

```java
int[] nums1 = new int[5];
int nums1[] = new int[5];
String[] names = new String[5];
Vector[] vecotrs = new Vector[5];
```
- C#처럼 new 키워드

```java
int[][] checkerboard = new int[8][8];
float[][][] world = new float[100][100][100];
```
진짜 다차원 배열이 아님.
- C#의 배열의 배열이나 C의 포인터 배열과 비슷함.
- 안쪽배열의 길이가 다를수있음.
- 가독성 측면에서 명확하게 구분된 C#이 더 좋음
```C#
int [,] table = new int[2,4]; //다차원 배열
int table[][] = new int[2][];  // 배열의 배열
```


# 열거형.

```JAVA
public enum Subject{
    KOREAN,
    ENGLISH,
    MATH
}

public class SchoolManager{
    public enum Subject{
        KOREAN,
        ENGLISH,
        MATH
    }
    ...
}
```
열거형은 독자적 또는 클래스 내부에 선언할 수 있음.

못하는것 : 값을 대입하지 못함.(C, C#에서는 가능)

java 열거형은 클래스형.
- 멤버 변수와 메서드를 가질 수 있음(C# 열거형은 클래스아님)
- 그냥 데이터로만 사용할 것.
- 이때 마지막 상수에 ; 붙여야함
```java
public enum Subject{
    KOREAN(2),
    ENGLISH(3),
    MATH(6);

    private int hours;
    public int getHours(){
        return hours;
    }
    Subject(int h){ // 언제나 private
        hours = h;
    }
}
```
- 생성자 추가가능.
- 생성자는 암시적으로 private
- 각각의 원소가 만들어질 때 생성자를 호출함
- 따라서 각 원소들은 생성자가 요구하는 매개변수를 반드시 넘겨줘야 함.
- new안씀
- C,C#과 동일하게 사용

```java
Subject subject1 = new Subject(); //compile error
Subject subject2 // OK
Subject subject3 = Subject.MATH;  // OK
```

# var

- java10부터 지원
- 컴파일러가 알아서 자료형을 추론해줌 동적타입아님
- 선언과 동시에 값을 대입하여야함
- C#의 var와 비슷

```java
var num = 10;
var message = "hello world!";
var error ;  // compile error

var scores = new int[20]; //ok
var numbers[] = new int[20]; //compile error

var world = new int[100][200][300]; //ok

var names = {"Lulu", "Nana", "Mama"}; //compile error
```

# 자바에는 LINQ가 없는가?
- 기본으로 제공안함
- JAVA 8부터 비슷한게 있음
  * Stream API
  * LINQ만큼 강력하진 않음
- 람다 지원

# 람다 표현식(lambda expression)

- 내포 함수라고도 부름
매개변수가 있는경우
```
(<매개 변수>) -> 표현식 몸통
(<매개 변수>) -> {표현식 몸통}
```

매개변수가 없는 경우
```
() -> 표현식 몸통
() -> {표현식 몸통}
```

```java
() -> System.out.println("HI");
(name) -> System.out.println("HI"+name); // 미완성코드
```
생략  


# 모듈

## 기존 패키지 시스템의 한계 

- 애플리케이션이 사용하는 클래스 목록을 찾는 공식적인 방법이 없음.
  * 누락된 클래스가 있다면 실행중에 그것을 사용하려 할 때 오류 발생
  * 따라서 사용중인 패키지가 있는 모든 클래스를 같이 배포하는 게 일반적
  * 문제점
    *  java 버전이 증가함에 따라 java자체 제공 라이브러리의 크기가 커짐
    *  안 사용하는 클래스까지 같이 배포하는 경우 쓸데없이 용량이 커짐
-  패키지 안에 있는 모든 public 클래스를 아무나 사용할 수 있음
-  때로는 그 중 일부만 외부에 노출하고 싶은데 그럴 수 없음.

## 모듈


```
pocu.academy.cor
| module-info.java
| academy
    | pocu
        | core
            |math
                |  .java
            ... 
                | .java
            xml
                | .java

```
- 자바9부터 지원
- 패키지보다 상위 개념(패키지를 내포함)
- 정말필요한 패키지만 포함할 수 있음.
- 프로그램 시작 시 누락된 모듈 확인가능
- 어떤 모듈이 사용하는 다른 모듈 목록을 찾기 쉬움
- 모듈 사용자에게 공개할 클래스를 특정할 수 있음.

## 이름
- 패키지와 마찬가지로 중복을 피해야함
- 여러 단어로 이루어진 경우 점을 찍음
- 단어 별로 폴더를 만들지 않음


## module-info.java
- 모듈간의 의존관계를 정의한 파일
- 컴파일 과정에서 .class 파일로 바뀜
- 모든 모듈에 반드시 존재해야함
- 이 파일에 들어가는 내용
  - 본 모듈 안에서 사용하는 외부 모듈 목록
  - 본 모듈 사용자에게 공개할 패키지 목록


```java
module pocu.academy.cor{
    exports pocu.academy.core.math; //공개범위
    requires java.sql;
}
```


