---
layout: post
comments : true
title:  "다형성"
date:   2025-01-08 22:53:01 +0900
---

# 다형성

- 어떤 개체가 다양한 형태로 변할 수 있는 능력


```java
public class Sloth extends Animal{
    public void shout(){
        ...
        super.shout();
    }
}
```

# 장점

- 캡슐화도 상승
- 유지 보수성 상승
- 새로운 클래스를 추가할 때 클래스 코드만 추가하면 됨
- 클라이언트가 작성할 코드가 줄어듦

# 늦은 바인딩 vs 이른 바인딩

- 다형적인 메서드는 실행중에 알 수 있음 late binding
- 이른 바인딩 : 컴파일 시간에 알 수 있음
- C에서 함수 포인터는 늦은 바인딩

## C에 없는 기능은 하드웨어에 없다.

- 컴파일러와 jvm이 함수 포인터 같은 걸 대신 전달해주는게 전부

## 성능

- 이른바인딩이 cpu 최적화가 더 잘 될 가능성이 높음
- 자바에서도 이른 바인딩이 가능

```java
public final int getHeight(){
    ...
}
public final class BsketballPlayer extends Athlete{
    ...
}
```

- cpp은 기본적으로 가상함수사용을 위해서는 따로 지정을 해줌
- C#,java는 모두 기본적으로 가상함수로 작동함
- class앞에 붙으면 더이상 상속못함


# 베스트 프랙티스 final은 기본적으로 붙인다.


# Object class , toString()

- 자바의 모든 클래스는 Object로부터 상속을 받음
- 어떤 클래스에서도 Object메서드를 오버라이딩 할 수 있음

## toString

- 사람이 읽기 편하게 해당 개체를 문자열로 표현
- 기본구현: getClass().getName() + '@' + Integer.toHexString(hashCode())

## equals()

- 오버라이딩 안할시 단순한 주소 비교: this == obj
- 실제 개체 속의 데이터를 일일이 비교하지 않음
- hashcode도 반드시 같이 오버라이딩해야함

```java
public boolean equals(Object obj){
    if(obj == this){
        return true;
    }
    if(obj == null || !(obj instancof Person)){
        return false;
    }
    Person p = (Person) obj;
    return this.firstName.equals(p.firstName) && this.lastName.equals(p.lastName)
}
//많이 실수 할 수 있음
```



## hashCode()

- 어떤 개체를 대표하는 해시값을 32비트 정수로 반환
  - 동치인 두 개체는 해시값이 같음
  - 동치가 아닌 두 개체도 해시값이 같을 수 있음
- Object 클래스안의기본 구현 : 개체의 주소를 반환
- 존재이유 : java가 제공하는 HashMap 클래스에서 사용하려고
- 빠른비교용으로 사용가능 : 같지 않음만 빠르게 판단가능

```java
public int hashCode(){
    return this.firstName.hashCode() ^ (this.lastName.hashCode() << 16);
}

public int hashCode(){
    return this.x * 31 + this.y;
}

public int hashCode(){
    int hash = 17;
    hash = hash * 31 + this.p1.hashCode();
    hash = hash * 31 + this.p2.hashCode();
    return hash
}
```

hashCode를 구현하는 보편적인 방법은 없음
구글에 hashcode best practice로 검색해 볼 것


